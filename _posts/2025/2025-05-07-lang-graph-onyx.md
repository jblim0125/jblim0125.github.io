---
layout: post
title: LangGraph 활용 사례
author: jblim0125
date: 2025-05-07
category: 2025
tags: [LangGraph]
---

## 개요

LangGraph 를 활용해 어떤 것을 하는지 알아보자.

## 본문

사용자가 기업 데이터에서 얻을 수 있는 지식과 통찰력을 확대하여 모든 직무 기능에서 생산성을 향상시키는 데 전념하고 있습니다.

**Onyx는 무엇인가요?**  

기업이 노트북, 온프레미스 또는 클라우드 등 어떤 규모로든 배포하여 Slack, Google Drive, Confluence 등
다양한 소스의 문서화된 지식을 연결할 수 있는 AI 비서입니다. Onyx는 LLM(프로젝트 관리)을 활용하여 팀을
위한 주제 전문가를 생성하여 사용자가 관련 문서를' 찾을 수 있을 뿐만 아니라 "X 기능은 이미 지원되나요?"
또는 "Y 기능에 대한 풀 리퀘스트는 어디에 있나요?"와 같은 질문에 대한 답변을 얻을 수 있도록 지원합니다.

Onyx는 다음과 같은 목표를 설정하여 엔터프라이즈 검색 및 지식 검색 기능을 강화하는데 착수했습니다.

* 복잡하고 모호한 질문에 대한 확장 가능한 답변을 제공합니다.
* 여러 엔터티가 관련된 경우 답변 품질 향상
* 질문의 핵심 측면에 대한 보다 풍부한 세부 사항과 맥락을 제공합니다.

이러한 범주에 속하는 질문은 일반적으로 사용자에게 매우 가치가 있지만, 기존의 RAG와 같은 시스템은 이런
상황에서 어려움을 겪는 경향이 있습니다.

예를 들어, "나이키와 푸마에서 포지셔닝한 제품 간의 차이점 중 판매 실적 차이에 영향을 미칠 수 있는 것은
무엇인가? "라는 질문을 생각해 보세요. 이 질문은 여러 측면을 아우르며, 모호함(제품 관련 판매 실적은
여러 의미를 가질 수 있음)도 내포하고 있습니다.

이 질문을 정확히 다루는 문서가 기업 데이터에 없는 한, RAG 시스템은 여기에서 좋은 답을 찾는 데 어려움을 겪습니다.

이런 종류의 질문을 할 때 새로운 에이전트 검색 기능이 필요합니다. 여기서 아이디어는 무엇일까요?

높은 수준에서 접근 방식은 1) 먼저 더 좁은 맥락에 초점을 맞추고 잠재적으로 모호한 용어의 모호성을 해소할
수 있는 하위 질문으로 질문을 분할하고, 2) 답변된 하위 질문과 가져온 문서를 사용하여 초기 답변을 구성한
다음, 3) 초기 답변과 초기 프로세스에서 학습한 다양한 사실을 기반으로 더욱 세부화된 답변을 생성하는 것입니다.

위의 예를 더 구체적으로 설명하자면, '퓨마와 어떤 제품에 대해 논의했는가?', '나이키와 어떤 제품에 대해 논의했는가?',
'퓨마에서 보고한 문제점은 무엇인가?' 등이 타당한 초기 하위 질문이 될 수 있습니다.
이러한 유형의 논리적 프로세스를 캡슐화하려면 많은 단계에 대해 계산 및 LLM과 연동을 구성하고 조율해야 합니다.

이 글의 목적은 1) 기능적 수준에서 이 문제에 어떻게 접근했는지 설명하고, 2) 기술 선택 접근 방식을 논의하고,
3) LangGraph를 백본으로 어떻게 활용했는지, 특히 어떤 교훈을 얻었는지 자세히 공유하는 것입니다.

이 글이 이 분야에 관심이 있거나 LangGraph를 사용하여 에이전트를 구축하고 당사의 요구 사항을 공유하고자 하는
독자에게 유용하기를 바랍니다.

### 일반 흐름 및 기술 요구사항

대략적으로, 우리가 목표로 삼은 논리적 흐름은 다음과 같습니다.

![alt text](/assets/images/langgraph/langgraph-onyx/image01.png)

이 흐름의 주요 측면과 요구 사항은 다음과 같습니다.

* 원래 질문에 대한 관련 문서를 직접 검색하는 것 외에도, 초기 질문을 더 좁고 명확하게 정의된 하위 질문으로
나눕니다. 이를 통해 모호성을 해소하고 검색 범위를 좁히는 데 도움이 됩니다.
* 분해는 초기 검색을 통해 알려지며 분해에 대한 맥락을 제공합니다.
* 각 하위 질문에 대한 답변은 쿼리 확장, 검색, 문서 검증, 재순위 지정, 하위 답변 생성, 하위 답변 검증 등
많은 부분으로 구성됩니다.
* 첫 번째 답변은 검색 + 하위 질문의 답변을 기반으로 합니다.
* 초기 답변에 부족한 부분이 있는 경우, 다시 분해하여 개선된 답변을 생성합니다. 이는 부족한 부분을
해결하고/하거나 하위 질문에 대한 답변을 보완하기 위한 것입니다. 이러한 개선 분해는 다음과 같은 요인에 의해
이루어집니다.
  * 질문과 원래 답변(그리고 그것이 부족하다는 사실)
  * 하위 질문과 그에 대한 답변(그리고 답변이 불가능한 하위 질문)
  * 문서 세트의 내용과 분해를 더 잘 일치시키기 위해 초기 검색을 기반으로 하는 별도의 엔터티/관계/용어 추출
* 전반적으로 병렬 처리가 다음을 포함한 여러 수준에서 필수적입니다.
  * 각 하위 질문 처리에 대한 문서 검증을 검색했습니다.
  * 여러 하위 질문을 병렬로 처리
  * 하위 질문 처리와 병행하여 엔터티/관계/용어 추출
* 마찬가지로 종속성 관리도 필수적입니다. 예를 들면 다음과 같습니다.
  * 정제 단계에서 분해는 초기 답변이 생성될 때까지(그리고 정제의 필요성이 결정될 때까지) 그리고 엔터티,
  관계 및 용어 추출이 완료될 때까지 기다려야 합니다.
  * 미래 단계는 이전 단계의 결과에 따라 결정됩니다.

따라서 우리의 목표를 달성하려면 훨씬 더 광범위하고 모호한 문제를 다루기 위해 많은 일이 일어나야 합니다.

이 흐름은 분명 워크플로 중심적이지만, 더 광범위한 에이전트 검색 흐름을 위한 첫걸음을 내딛는 것입니다.
다양한 도구를 이 흐름에 연결하고, 개선 프로세스를 업데이트하는 등의 작업을 진행할 예정입니다. 추후에는
개선 전에 답변을 승인하거나, 일부 수동 변경 사항을 적용하여 흐름의 일부를 다시 실행하는 등, 사용자와
'인간 참여형(Human-in-the-Loop)' 방식의 상호작용을 도입할 가능성도 있습니다.

가까운/중기 미래를 염두에 두고 우리의 요구 사항을 해결하려면 프레임워크가 필요합니다.

1. 잘 통제되고 있습니다,
1. 확장하거나 (재)구성하기 쉽습니다.
1. 비용 효율적입니다,
1. 높은 수준의 병렬화가 가능합니다.
1. 논리적 종속성을 관리할 수 있습니다(A와 B는 C가 시작되기 전에 완료되어야 하며
   E는 이 모든 것과 병렬로 실행될 수 있음 등).
1. 토큰 및 기타 객체의 스트리밍을 가능하게 합니다.
1. 앞으로 더욱 복잡한 상호작용이 가능해집니다.

그리고 답변도 사용자 기대에 맞춰 시기적절하게 제공되어야 하며, 대규모로 제공되어야 합니다.

그래서 우리가 해결해야 할 핵심 질문은 "이것을 어떻게 가장 잘 구현할 수 있을까?"였습니다.

### 프레임워크 옵션 및 평가 접근 방식

우리에게 주어진 선택지는 기존 흐름을 확장하여 처음부터 직접 이 흐름을 구현할 것인지, 아니면 기존의 에이전트
프레임워크를 활용할 것인지, 그리고 만약 그렇다면 어느 것을 활용할 것인지였습니다.

위에서 설명한 우선순위를 고려하여 우리는 구현 프레임워크의 주요 후보로 `LangGraph`를 선정했고, 처음부터
구현하는 것이 그 다음으로 적합할 것으로 보입니다.

LangGraph를 지지하는 요인

* 자연스러운 "그들의 그림이 우리의 그림과 같다"는 상황, 즉 우리가 배치한 흐름이 LangGraph의 노드,
  에지, 상태 개념에 매우 잘 매핑된다는 의미입니다.
* 강력한 커뮤니티를 갖춘 오픈 소스 프레임워크
* '완전히 새로운 것은 아니다'(이 분야의 혁신 시간 척도와 관련해서)
* 높은 수준의 제어
* 네이티브 스트리밍 지원
* Human-in-the-Loop 또는 일부 매개변수를 변경하여 에이전트 흐름을 다시 실행하는 기능과 같은 잠재적인
향후 `Onyx` 기능에 대한 흥미로운 기능

그러나 우리는 다음과 같은 사항을 포함하여 처음부터 구현하는 데 유리한 몇 가지 우려 사항도 확실히 가지고 있었습니다.

* 제3자에 대한 의존성 및 엔드투엔드 제어 감소
* LangGraph의 변경 가능한 상태 변수('누가 이 값을 변경했나요?')
* 디버깅 목적으로 호출 스택에 대한 가시성이 낮음
* 기존 흐름의 변화

이러한 유형의 문제들은 대부분의 프로젝트에서 그렇듯이, 저희는 결정을 내리기 위해 프로토타입 평가부터
시작했습니다. 구체적으로, 저희는 목표 흐름에 맞춰 간소화된 독립형 `LangGraph` 구현을 빠르게 (학습 내용 포함
약 1주일/1FTE) 구현하고, 다음과 같은 테스트를 시도했습니다.

* 허용 가능한 실행 시간을 제공하는 대략적인 엔드투엔드 기능
* 팬아웃 병렬화
* 서브그래프 병렬화
* 국가 관리와 관련된 잠재적 문제
* 스트리밍

결과는 고무적이었고, 저희는 `LangGraph`에서 실제 흐름을 애플리케이션 내에 구현하기 시작했습니다. 예상대로
이 과정에서 여러 가지 추가적인 교훈을 얻었습니다. 아래에는 저희가 배운 내용과 에이전트 흐름 활용이 확대됨에
따라 앞으로 따르고자 하는 규칙들을 정리했습니다.

### LangGraph Learnings - 앞으로 나아갈 모범 사례

프로젝트가 점점 더 복잡해지면서 우리가 관찰한 내용과 고수한 관행 중 일부는 다음과 같습니다.

#### 코드 구성

**디렉토리 및 파일 구조**  

* 복잡한 그래프에서는 노드 수가 상당히 많아질 수 있습니다.
  따라서 파일당 노드 1개(여러 노드에 대한 함수 재사용 모듈로) 방식을 사용하기로 했습니다.
* 노드가 많을 경우 명확한 디렉터리 구조와 파일 명명 전략이 권장됩니다.
  각 하위 그래프에 대한 디렉터리를 생성하고 일반적으로 `<action>_<object>.py` 명명 규칙을 사용했습니다.
  단계 번호에 숫자를 추가하는 것도 도움이 될 수 있지만, 노드를 추가하거나 제거할 때 추가 작업이 필요합니다.
* 병렬화(아래 참조) 및 재사용을 위해 하위 그래프를 광범위하게 사용합니다. 각 하위 그래프 디렉터리에는
  자체적인 에지, 상태 및 모델 파일과 그래프 빌더가 있습니다.
* 그래프를 시각화하려면 전체 그래프의 inner png를 사용하는 것이 매우 유용한 것으로 입증되었습니다.

**타이핑 및 상태 관리**  

저희는 코드베이스 전반에 걸쳐 `Pydantic`을 사용하고 있기 때문에 `LangGraph`가 `TypeDict` 외에도 `Pydantic`
모델을 지원한다는 점이 매우 좋았습니다. 따라서 `LangGraph` 구현 전체에서도 `Pydantic` 모델을 사용합니다.
(아쉽게도 그래프 출력의 경우 `Pydantic`은 아직 지원되지 않습니다.)

하위 그래프 내에 자체 동작과 '출력'(상태 업데이트)을 가진 여러 노드가 있으므로, 일반적으로 노드 업데이트에
의해 결정되는 (하위)그래프 상태를 살펴봅니다. 따라서 하위 그래프 상태 내에서 키를 직접 정의하는 대신,
다양한 노드 업데이트에 대한 `Pydantic` 상태 모델을 정의한 다음, 다양한 노드 업데이트(및 기타) 모델을
상속하여 그래프 상태를 구성합니다.

*이익:*  

* 키는 자연스럽게 그룹화됩니다
* 키를 추가할 때 노드 상태 모델(및 노드)만 업데이트하면 됩니다.
* 키의 중복이 허용됩니다
* 기본값이 허용됩니다

*과제:*  

* 이런 접근 방식을 따르면 전체 그래프 상태에서 전체 키 세트를 보는 것이 조금 더 어려워집니다.
* 상속 문제를 피하려면 좋은 구조를 선택해야 합니다.

당연히 상태 키의 기본값을 신중하게 설정하는 것은 매우 중요합니다. 주의 깊게 다루지 않으면 부적절한
상황에서 기본값을 설정하면 감지하기 어려운 의도치 않은 동작이 발생할 수 있습니다. 예를 들어 다음과
같은 문제가 있는 구성을 생각해 보겠습니다.

![alt text](/assets/images/langgraph/langgraph-onyx/image02.png)

여기서 메인 그래프 노드 A는 'my_key'를 'my_data'로 설정합니다. 이 값은 나중에 내부 서브그래프 노드에서
사용되도록 의도된 값입니다. 하지만 이 예제에서는 (의도적으로) 해당 키를 외부 서브그래프에 추가하지 않았습니다.
당연히 내부 서브그래프의 이 키 값은 빈 문자열이 됩니다. 출력 측에서도 비슷한 상황이 발생합니다. 내부
서브그래프 노드 C에서 'my_key'를 업데이트해도 메인 그래프의 'my_key' 상태는 업데이트되지 않습니다.

대신 조심해서 다음과 같이 내부 서브그래프의 'my_key'에 기본값을 설정하지 않았더라면 좋았을 텐데요.

![alt text](/assets/images/langgraph/langgraph-onyx/image03.png)

그러면 'my_key'에 내부 하위 그래프에 대한 입력 값이 없으므로 오류가 발생합니다. 그런 다음, 외부 하위
그래프에서 누락된 상태를 추가하여 적절한 구성을 얻습니다.

![alt text](/assets/images/langgraph/langgraph-onyx/image04.png)

물론 이는 기존의 중첩 함수와 크게 다르지 않지만, 저희 경험상 LangGraph 환경에서는 이러한 문제를 파악하기가
조금 더 어렵습니다.

저희가 권장하는 사항은 다음과 같습니다.

* 일반적으로 중첩된 하위 그래프의 컨텍스트에서 문서화된 예외를 제외하고 기본값 없이 그래프 입력 상태의 모든 키를 정의합니다.
* 그래프에서 업데이트되는 모든 키를  `<type> | None = None` 으로 정의합니다. 단, 키가 목록이고 여러 노드에서 목록에 추가하려는 경우는 예외입니다.

#### 그래프 구성 요소 및 고려 사항

**병행**  

프로세스가 병렬로 실행되어야 한다는 요구 사항이 많으며, 병렬성에는 여러 유형이 있습니다.

*동일한 흐름의 병렬성 :*

'맵리듀스 브랜치' 이러한 유형의 병렬 처리의 예로는 검색된 문서의 검증, 즉 검색된 문서 목록에 있는
각 문서가 질문과의 관련성을 갖는지 테스트하는 것입니다. 이러한 테스트는 병렬로 수행해야 하며,
`LangGraph`의 '맵리듀스 브랜치'는 이러한 상황에서 매우 효과적입니다.

![alt text](/assets/images/langgraph/langgraph-onyx/image05.png)

위에서 **굵은 글씨로 표시된 상태 키**는  팬아웃 중에 업데이트되는 키이고, 이탤릭체로 표시된 키는
팬아웃 노드 내부 변수를 나타냅니다.

*뚜렷한 흐름 세그먼트의 평행성:*

서브그래프의 광범위한 활용! 다음 상황에서 B_1과 B_2는 각각 5초가 걸리는 반면 C는 8초가 걸린다고 가정해 보겠습니다.
왼쪽 시나리오에서 D는 A가 완료된 후 실제로 13초 후에 시작됩니다. *B_2는 B1과 C가 완료된 후에만 시작*되기 때문입니다.
반면 오른쪽 시나리오에서는 D가 A가 완료된 후 10초 후에 시작됩니다. B_1과 B_2를 서브그래프로 감싸면 부모 그래프
관점에서 왼쪽과 오른쪽에 노드가 하나씩 존재하게 되며, B_2의 실행은 C가 완료될 때까지 기다리지 않습니다.
(참고: 부모 그래프의 노드 내에서 서브그래프를 호출하는 대신, 항상 부모 그래프 내의 노드로 서브그래프를 사용합니다.)

![alt text](/assets/images/langgraph/langgraph-onyx/image06.png)

**재사용 가능한 구성 요소:  하위 그래프입니다!**  

여러 노드로 구성된 반복적인 흐름 세그먼트가 많이 있습니다. 한 가지 예로, 주어진 (하위) 질문에 대한 문서를 검색하는
확장 검색(Extended Search Retrieval)이 있습니다. 이 프로세스의 핵심은 검색, 검색된 각 문서의 질문 관련성 검증,
그리고 검증된 문서의 순위 재지정으로 구성됩니다. 이 반복적인 프로세스를 효율적으로 만들기 위해, 이 프로세스를 하위
그래프로 묶어 메인 그래프 또는 다른 하위 그래프에서 사용합니다. 항상 그렇듯이, 상위 그래프와 하위 그래프 간의
키 정의 및 공유에는 주의해야 합니다.

* 노드 구조
  * 우리는 일반적으로 '노드당 하나의 작업' 방식을 채택하지만, 더 많은 연속 작업을 하나의 노드에 넣으면 노드 확산을
    쉽게 줄일 수 있습니다.
  * 흐름의 여러 단계에서 하위 그래프가 사용되는 경우, 때로는 원하는 키 업데이트로 데이터를 변환하는 역할을 하는
    '포맷팅 노드'를 끝에 도입하는 것이 편리하다는 것을 알게 됩니다.
* 스트리밍
  * 사용자 정의 이벤트의 노드 내 스트리밍:
    우수한 사용자 경험을 제공하려면 노드 내에서 많은 이벤트를 스트리밍해야 합니다. 예를 들어 검색된 문서, 생성된
    답변 또는 하위 답변의 LLM 토큰 등이 있습니다. 이러한 이벤트 중 상당수는 사용자 정의 이벤트인데, 동시에
    스트리밍될 수 있는 개별 하위 답변을 구분해야 하기 때문입니다. 저희 애플리케이션은 동기식 작업을 사용하며,
    LangGraph의 스트리밍 설명서를 따르면 사용자 정의 이벤트 스트리밍을 원활하게 진행할 수 있었습니다.
* LangGraph 버전
  * 이것은 빠르게 변화하는 분야이자 빠르게 움직이는 프로젝트이므로 릴리스에 대한 최신 정보를 얻는 것이 중요합니다.

#### LangGraph를 이용한 현재 에이전트 검색

마지막으로, 현재 그래프는 다음과 같습니다(복잡성을 제한하기 위해 X선 수준을 1로 설정했으므로 여러 노드가 실제로
하위 그래프이며 추가 하위 그래프를 포함할 수 있음).

![alt text](/assets/images/langgraph/langgraph-onyx/image07.png)

이 흐름은 처음에 설명한 논리적 흐름과 매우 유사하며, 에이전트 검색이 선택되지 않은 경우 기본 검색 흐름을 용이하게 하기 위한 몇 가지 추가 사항이 있다는 것이 분명합니다.

**Outlook 및 행동 촉구**  

저희는 이 구현을 첫 단계로 보고 있으며, 가까운 시일 내에 흐름을 확장하여 훨씬 더 에이전트적인 방식으로 구현할 계획입니다.
LangGraph는 지금까지 저희의 요구에 매우 적합했습니다.

GitHub 에서 agent-search를 확인하고,  데모를 예약하고, 클라우드 버전을 무료로 사용해보고,
Slack, Discord `#agent-search` 채널에 가입하여 Enterprise AI Search와 Agents에 대해 더 광범위하게 논의해보세요!

## 참고 사이트

[원문](https://blog.langchain.dev/beyond-rag-implementing-agent-search-with-langgraph-for-smarter-knowledge-retrieval)
