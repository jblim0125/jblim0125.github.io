---
layout: post
title: "인증(session, jwt)"
author: jblim0125
date: 2024-06-15
category: 2024
---

## 웹 인증 - Session, JWT

인증 기술을 알아보기 전에 우선 쿠키에 대해서 먼저 알아보자.  
인증에서 사용되는 클라이언트 - 서버 사이에 주고 받는 데이터가 쿠키 형태로 저장되고 사용되기 때문이다.  

> JWT의 토큰은 다양한 방식으로 저장할 수 있다

JWT 기반의 액세스 토큰과 리프레시 토큰을 쿠키에 저장하는 것은 보안과
사용 편의성 측면에서 많은 장점을 제공할 수 있습니다. 특히 HttpOnly, Secure, SameSite 속성을
적절히 설정하면 XSS 및 CSRF 공격으로부터 보호할 수 있습니다. 하지만 각 애플리케이션의 보안
요구사항과 환경에 따라 적절한 저장 방식을 선택하는 것이 중요합니다.

### Cookie

쿠키는 웹 서버가 생성하여 웹 브라우저로 전송하는 작은 정보 파일입니다.  

1. 데이터 저장  
  쿠키는 사용자의 브라우저에 저장되는 작은 텍스트 파일로, 서버가 사용자에 대한 상태 정보를 저장하기 위해 사용됩니다.

2. 키-값 쌍  
  쿠키는 키-값 쌍의 형태로 저장되며, 예를 들어 user=JohnDoe와 같은 형식입니다.

3. 도메인 및 경로 지정  
  쿠키는 특정 도메인과 경로에 대해 유효하도록 설정할 수 있습니다. 따라서, 지정된 도메인 및 경로에 대한 요청에만 쿠키가 전송됩니다.

4. 유효 기간  
  쿠키는 유효 기간을 가질 수 있습니다. Expires나 Max-Age 속성을 통해 쿠키의 수명을 지정할 수 있으며, 이 기간이 지나면 쿠키는 자동으로 삭제됩니다.  
  영구 쿠키: 유효 기간이 설정되어 있는 쿠키로, 브라우저가 종료되어도 유지됩니다.  
  세션 쿠키: 유효 기간이 설정되지 않은 쿠키로, 브라우저가 종료되면 삭제됩니다.  

5. 보안 속성  
  Secure 속성: 이 속성이 설정된 쿠키는 HTTPS 연결에서만 전송됩니다.  
  HttpOnly 속성: 이 속성이 설정된 쿠키는 자바스크립트에서 접근할 수 없으며, XSS(교차 사이트 스크립팅) 공격을 방지하는 데 도움이 됩니다.  
  SameSite 속성: 이 속성은 쿠키가 동일 사이트 요청에서만 전송되도록 하여 CSRF(교차 사이트 요청 위조) 공격을 방지하는 데 도움이 됩니다. Strict, Lax, None 값이 사용됩니다.

6. 크기 제한  
  쿠키는 보통 한 도메인당 최대 4KB의 크기 제한이 있으며, 브라우저마다 저장할 수 있는 쿠키의 최대 수에도 제한이 있습니다.

7. 전송 메커니즘  
  클라이언트가 서버에 요청을 보낼 때마다 해당 도메인과 경로에 맞는 쿠키가 자동으로 전송됩니다. 서버는 응답 헤더를 통해 새로운 쿠키를 설정하거나 기존 쿠키를 업데이트할 수 있습니다.

### Session 인증

쿠키만을 이용한 인증의 보안에 취약점과 한계를 보완하여 민감 정보를 서버에 저장하고,
세션 고유 키를 발급하여 이를 쿠키로 주고 받는다.  

![세션인증](/assets/images/jwt/session_image01.png)
![세션인증-2](/assets/images/jwt/session_image02.png)

Client(web browser), Server(Web Server), Session Storage(file, DB, memory)

세션 기반 인증의 기본적인 프로세스는 다음과 같습니다.  

1. 사용자의 인증(ID/PW)이 완료되면 서버는 세션을 발급합니다.  
2. 이후 서버는 세션 값을 포함한 클라이언트의 상태를 세션 스토리지에 저장합니다.  
3. 세션 스토리지로 파일, DB, 메모리가 사용될 수 있습니다. 클라이언트 또한 자신의 세션
값을 클라이언트에 저장(주로 쿠키)합니다.  
4. 클라이언트는 데이터 요청 시 쿠키에 저장된 세션 값을 함께 보내며, 서버에서는 이 세션 값을
세션 스토리지를 통해 검증한 후 데이터 응답을 합니다.  

쿠키만을 전송할 때와는 다르게 세션 저장소에 식별할 수 있는 값을 넣어두고 그 값이 일치하는지
확인하는 과정의 추가로 보안에 대한 부분이 향상되었습니다.  
또한 쿠키 값(세션 아이디)이 탈취되는 문제가 발생할 경우 서버에서 인증정보를 삭제할 수 있습니다.  

하지만 세션 저장소에 문제가 발생할 경우 서비스 전체에 문제가 발생할 수 있고, http의 장점이라고 할 수 있는
STATELESS를 위배합니다. 서버 확장(Scale Out) 시에도 세션 저장소에 대한 고려가 되어 있지 않을 경우 확장이 불가능합니다.  

#### 세션 인증의 보안 고려사항

* 세션 탈취 방지  
  세션 ID를 탈취 당하지 않도록 HTTPS를 사용하여 통신을 암호화한다.  
  HttpOnly 쿠키 속성을 사용하여 클라이언트 측 스크립트에서 세션 ID에 접근하지 못하도록 한다.  
* 세션 고정 방지  
  로그인 후 새로운 세션 ID를 발급하여 세션 고정 공격을 방지  
* 세션 만료 관리  
  세션의 유효 기간을 설정하여 오래된 세션이 남아 있지 않도록 한다.  
  일정 시간 동안 활동이 없는 경우 세션을 자동으로 만료시킨다.  
* 동시 세션 제한  
  한 사용자가 동시에 여러 곳에서 로그인을 시도하는 것을 제한할 수 있습니다.  
  이와 같은 세션 인증 기법은 대부분의 웹 애플리케이션에서 사용되며, 사용자의 신원을 확인하고 지속적인 상호작용을 관리하는 데 중요한 역할을 합니다.  

## JWT

토큰은 사용자 인증을 위한 정보를 서명한 것입니다. 세션 기반의 인증은 클라이언트의 상태를
서버 내에 저장하며, 요청마다 세션 스토리지에 저장된 유효한 세션인지 확인해야 합니다.  
반면 토큰 기반의 인증 방법은 토큰에 사용자 인증을 위한 정보가 담겨있기 때문에 서버에 사용자 정보를
서버에 저장하지 않고, 전달받은 토큰의 서명과 데이터를 검증하는 것만으로 인증이 가능합니다.

![토큰인증](/assets/images/jwt/token_image01.png)

사용자의 인증(ID/PW)이 완료되면 서버는 비밀키 또는 공개/개인 키를 이용해 서명한 토큰을 클라이언트에게 전달합니다.
그리고 데이터 요청 시 클라이언트는 토큰을 포함합니다(주로 헤더). 서버는 토큰의 서명 값을 이용하여 토큰이
유효한지 검증하는데요. 유효한 토큰인 경우 요청에 응답합니다. 토큰 발급 시 토큰 내 권한 정보를 추가하여
권한에 맞는 데이터 응답도 가능합니다.

### 세션 기반 인증과 토큰 기반 인증의 차이점

* 정보 포함  
  세션 값 자체에는 정보가 포함되지 않지만, 토큰값에는 정보가 포함됩니다. 토큰에는 정보가 포함되어 있기 때문에 일반적으로 길이가 더 깁니다.  

* 상태 정보 미저장  
  세션 방식은 상태 정보를 서버 내에 저장하고 있습니다. 이에 비해 토큰은 기본적으로 서버에 클라이언트 상태를 저장하지 않는 무상태성 방식입니다. 서버에 정보를 저장할 필요가 없기 때문에 서버를 확장하는데 제약이 적죠. 또한, 저장 없이 유효한 토큰인지 검증만 필요하기 때문에 다른 플랫폼, 서비스 간에 사용하기도 편리합니다.  

### 구조  

JWT는 크게 헤더, 페이로드, 서명 세 개의 파트로 구성되어 있습니다.  

![토큰구조](/assets/images/jwt/token_image02.png)

#### 헤더(Header)

헤더는 보편적으로 토큰 타입을 명시하는 “typ”와 HMAC,
SHA256 등의 서명 알고리즘을 적는 “alg”로 이루어져 있습니다.  

#### 페이로드(Payload)

페이로드에는 토큰에 담을 정보가 들어있습니다. 여기에 담는 정보의 한 ‘조각’ 을 클레임(claim) 이라고 부르고,
이는 name / value 의 한 쌍으로 이뤄져있습니다. 토큰에는 여러개의 클레임들을 넣을 수 있습니다.

클레임의 종류는 다음과 같이 크게 세 분류로 나뉘어져있습니다:

* Registered 클레임  
* Public 클레임  
* Private 클레임  

1. Registered claims  
    서비스에 필요한 정보가 아닌 토큰에 관한 정보를 담기 위해 이미 등록된 클레임입니다.
    반드시 사용할 필요 없이 선택적으로 사용할 수 있습니다.  

    | 이름 | 설명 |
    |---|---|
    |iss| 토큰 발급자 (issuer)|
    |sub| 토큰 제목 (subject)|
    |aud| 토큰 대상자 (audience)|
    |exp| 토큰의 만료시간 (expiraton), 시간은 NumericDate 형식으로 되어있어야 하며 (예: 1480849147370) 언제나 현재 시간보다 이후로 설정되어있어야합니다.|
    |nbf| Not Before 를 의미하며, 토큰의 활성 날짜와 비슷한 개념입니다. 여기에도 NumericDate 형식으로 날짜를 지정하며, 이 날짜가 지나기 전까지는 토큰이 처리되지 않습니다.|
    |iat| 토큰이 발급된 시간 (issued at), 이 값을 사용하여 토큰의 age 가 얼마나 되었는지 판단 할 수 있습니다.|
    |jti| JWT의 고유 식별자로서, 주로 중복적인 처리를 방지하기 위하여 사용됩니다. 일회용 토큰에 사용하면 유용합니다.|

2. Public claims  
    사용자가 정의할 수 있는 클레임입니다. 이 클레임은 충돌 방지를 위해 IANA(Internet Assigned Numbers Authority) JSON 웹 토큰 레지스트리에 정의하거나, 충돌 방지 네임스페이스를 포함하는 URI로 클레임 이름을 정의해야 합니다.

    ```json
    {
      "https://velopert.com/jwt_claims/is_admin": true
    }
    ```  

3. Private claims  
    토큰 사용자 간(서버-클라이언트) 정보 공유를 위해 만들어 사용하는 클레임으로 충돌이 발생할 수 있으니 주의해야 합니다.  

4. 예제 Payload  

    ```json
    {
      "iss": "velopert.com",
      "exp": "1485270000000",
      "https://velopert.com/jwt_claims/is_admin": true,
      "userId": "11028373727102",
      "username": "velopert"
    }
    ```

    위 예제 payload 는 2개의 등록된 클레임, 1개의 공개 클레임, 2개의 비공개 클레임으로 이뤄져있습니다.  

#### 서명(Signature)

서명 부분은 헤더와 페이로드를 서명한 값입니다. 시크릿 키를 이용해 base64 url로 인코딩한 헤더와 페이로드를 헤더에 규정된 해싱 알고리즘으로 서명합니다. 서버는 이 서명과 전달된 헤더, 페이로드를 같은 알고리즘으로 해시한 값이 동일한 것을 확인함으로써 유효한 토큰인지 검사합니다.

**특징**  

JWT는 x.509 형식의 public/private 키를 사용할 수 있습니다.
SAML(Security Assertion Markup Language)방식도 public/private 키를 사용할 수 있지만,
보안의 허점 없이 디지털 서명을 사용하기에는 JWT가 더 쉽습니다.

JWT는 다른 토큰 방식인 SAML에 비교해 사이즈가 작다는 장점을 갖고 있습니다.
SAML은 XML 형식을 사용하나, JWT는 JSON 형식을 사용해 더 간결하기 때문에 HTTP 환경에
잘 전달될 수 있습니다. SAML은 토큰과 기본 프로토콜의 구조를 정의할 수 있으며, 기업에서 많이 사용됩니다.
이와 다르게 JWT는 토큰 구조만을 정의할 수 있는데요. 인터넷의 여러 플랫폼에서 사용되며 특히 모바일에서 많이 사용됩니다.

기본적으로는 클라이언트가 인증 정보를 관리하기 때문에 쿠키 인증 방식과 Flow가 비슷합니다.
차이가 있는 부분은, 쿠키가 아닌 JWT 토큰을 매개체로 인증한다는 것과 서버에서 '토큰 검증'이 이루어진다는 점입니다.
이를 통해 쿠키보다는 보안적으로 안전하게 관리될 수 있습니다.

## JWT AccessToken & RefreshToken

제 3자에게 Token을 탈취 당한다면 서버는 탈취 당한 사실 여부를 알 수 없기에
Access Token, Refresh Token을 나누어 보안성을 강화한다.  

만약, 해커가 JWT AccessToken을 탈취한다면? 해커는 탈취한 AccessToken을
사용하여 접근이 모두 가능해질 것입니다. 이를 해결하기 위해, AccessToken의
유효 기간을 짧게 하면 해결할 수 있습니다. 만약 해커가 탈취를 하더라도,
그 AccessToken을 짧은 시간동안 밖에 못 쓰기 때문에 대응이 되는 것입니다.  

하지만, AccessToken의 유효 기간을 짧게 설정하게 되면 유저 입장에서 매우 귀찮고 번거로울 것입니다.
로그인 한지 얼마 되지도 않아 다른 페이지를 이동할 때 다시 로그인을 해서 AccessToken을 발급 받아야하기 때문입니다.

따라서, 해커 탈취 문제-사용자의 이용성에 trade-off가 발생하게 되는 것입니다.
이러한 trade-off를 해결해 주는 것이 바로 RefreshToken입니다.
RefreshToken은 인증이 아닌, AccessToken을 재발급 해주는 역할의 Token입니다.  

1. 액세스 토큰 (Access Token)  
    역할: 리소스 서버(API 서버)에 대한 접근 권한을 부여하는 데 사용됩니다.  
    유효 기간: 짧은 유효 기간을 가집니다 (일반적으로 몇 분에서 몇 시간).  
    용도: 보호된 리소스에 접근할 때 클라이언트가 이 토큰을 포함하여 요청을 보냅니다.  
2. 리프레시 토큰 (Refresh Token)  
    역할: 새로운 액세스 토큰을 발급받는 데 사용됩니다.  
    유효 기간: 비교적 긴 유효 기간을 가집니다 (며칠, 몇 주 또는 몇 달).  
    용도: 액세스 토큰이 만료되었을 때, 클라이언트가 리프레시 토큰을 이용해 새로운 액세스 토큰을 요청합니다.  

### 액세스 토큰과 리프레시 토큰을 이용한 인증 흐름  

![토큰인증흐름](/assets/images/jwt/token_image03.png)

1. 사용자 인증  
    사용자가 클라이언트 애플리케이션(예: 웹 앱, 모바일 앱)에 로그인합니다.  
    클라이언트 애플리케이션은 사용자의 자격 증명(예: 사용자 이름과 비밀번호)을 인증 서버에 전달합니다.  
2. 토큰 발급  
    인증 서버는 사용자의 자격 증명을 확인하고, 클라이언트 애플리케이션에 액세스 토큰과 리프레시 토큰을 발급합니다.  
    클라이언트 애플리케이션은 이 토큰들을 안전하게 저장합니다.  
3. 리소스 접근  
    클라이언트 애플리케이션은 보호된 리소스(API 서버)에 접근할 때 액세스 토큰을 요청 헤더에 포함하여 전송합니다.  
    예: Authorization: Bearer {access_token}  
    리소스 서버는 액세스 토큰을 검증하고, 유효한 경우 요청된 리소스를 반환합니다.  
4. 액세스 토큰 만료  
    액세스 토큰이 만료되면, 클라이언트 애플리케이션은 보호된 리소스에 접근할 수 없습니다.  
5. 토큰 갱신  
    클라이언트 애플리케이션은 리프레시 토큰을 포함하여 인증 서버에 새로운 액세스 토큰을 요청합니다.
    예: POST 요청을 통해 grant_type=refresh_token과 함께 리프레시 토큰을 전송합니다.

    ```http
    POST /{....}
    Content-Type: application/x-www-form-urlencoded

    grant_type=refresh_token&refresh_token={refresh_token}&client_id={client_id}
    ```

6. 새로운 토큰 발급  
    인증 서버는 리프레시 토큰을 검증하고, 유효한 경우 새로운 액세스 토큰을 발급합니다.  
    필요한 경우 새로운 리프레시 토큰도 함께 발급합니다.  
7. 재시도  
    클라이언트 애플리케이션은 새로 발급받은 액세스 토큰을 사용하여 보호된 리소스에 다시 접근합니다.

### 보안 고려사항

1. 토큰 저장  
    클라이언트 측에서 액세스 토큰과 리프레시 토큰을 안전하게 저장해야 합니다.  
    웹 애플리케이션에서는 브라우저의 로컬 스토리지보다는 보안 쿠키를 사용하는 것이 좋습니다.  
2. 토큰 유효 기간  
    리프레시 토큰의 유효 기간은 너무 길지 않게 설정하여 보안 위험을 줄입니다.
3. HTTPS 사용  
    모든 토큰 전송은 HTTPS를 통해 암호화된 채널에서 이루어져야 합니다.
4. 토큰 무효화  
  사용자가 로그아웃할 때, 서버에서 리프레시 토큰을 무효화하여 보안을 강화합니다.
  이러한 방식으로 액세스 토큰과 리프레시 토큰을 이용한 인증은 안전하고 효율적인 사용자 인증을 제공합니다.

## 마무리  

JWT 구현 다음 시간에 이어서 진행...
